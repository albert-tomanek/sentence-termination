1
00:00:00,130 --> 00:00:03,310
previously we look at how we can build a
simple memory circuit

2
00:00:03,310 --> 00:00:08,189
from NOR gates. Today we're gonna look at
how we can take this further and see how

3
00:00:08,189 --> 00:00:11,929
computer memory's built in a bit more
detail.

4
00:00:11,980 --> 00:00:15,179
So if you remember the previous video, and if you haven't seen it

5
00:00:15,179 --> 00:00:19,020
well, click the link below. We had this
circuit here, which has got two

6
00:00:19,020 --> 00:00:22,900
NOR gates in it, wired so that the output of
one NOR gate

7
00:00:22,900 --> 00:00:27,050
feeds back to the input of the other and so
on with the other one.

8
00:00:27,050 --> 00:00:31,230
We had two inputs to the circuit S and
R which stood for 'set'

9
00:00:31,230 --> 00:00:35,780
and 'reset' & we had two outputs Q and Q bar which is the inverted Q.

10
00:00:35,780 --> 00:00:39,120
If we took the set input high

11
00:00:39,129 --> 00:00:43,829
the output went high and it remained
high even if the set output went

12
00:00:43,829 --> 00:00:47,230
low again and the same with the reset
thing. If we took that high

13
00:00:47,230 --> 00:00:50,329
then it reset Q back to zero, or low

14
00:00:50,329 --> 00:00:53,960
and so on. The circuit remembered what
state we put it in.

15
00:00:53,960 --> 00:00:57,360
So this is a useful circuit, it's referred
to as an SR latch

16
00:00:57,360 --> 00:01:00,930
but often we want to store not just
setting a bit

17
00:01:00,930 --> 00:01:04,479
and resetting it we actually want to store
whatever data is on this

18
00:01:04,479 --> 00:01:08,080
line which we'll call D for 'data', So we're gonna have another input

19
00:01:08,080 --> 00:01:11,229
which we'll call 'clock' and when that's
high,

20
00:01:11,229 --> 00:01:14,590
we want that to remember whatever data
is on D. So let's have a look at how we

21
00:01:14,590 --> 00:01:16,979
can map these inputs into the inputs

22
00:01:16,979 --> 00:01:20,659
of our previous circuit to do that. So it helps if we actually have a look

23
00:01:20,659 --> 00:01:25,259
at the truth table of what input we have
coming in. So we've got our data bit coming in

24
00:01:25,259 --> 00:01:28,720
and we have our clock signal coming in
and we're going to produce

25
00:01:28,720 --> 00:01:33,040
outputs S and R. Now we need to map these

26
00:01:33,040 --> 00:01:37,130
to the outputs S & R so whenever clock is
zero we don't want the values to

27
00:01:37,130 --> 00:01:39,299
change so we want the output to S & R

28
00:01:39,299 --> 00:01:43,040
to be zero. Now if the data is 0 and clock
is 1

29
00:01:43,040 --> 00:01:47,240
then we want the thing to be reset so we want the reset pin to be high

30
00:01:47,240 --> 00:01:50,970
so we want S to have 0 output from it and we want R

31
00:01:50,970 --> 00:01:54,649
to have a 1 output from it. If
D is 1

32
00:01:54,649 --> 00:01:58,180
and clock is 1 then we want to change
the value 'cause our clock pin is high

33
00:01:58,180 --> 00:02:03,140
D is 1 so we want to set it. So we want to take S to be 1 and R to be 0.

34
00:02:03,140 --> 00:02:07,360
So we now know for all
of our inputs, what we want the outputs to be

35
00:02:07,360 --> 00:02:10,560
and so we need to build a set of logic
gates here

36
00:02:10,560 --> 00:02:12,500
that will map these inputs to the

37
00:02:12,500 --> 00:02:17,730
outputs here. So we need to think of some circuit that is true

38
00:02:17,730 --> 00:02:21,040
for S when both D is 1 and clock is 1

39
00:02:21,040 --> 00:02:24,960
If you remember your logic
gates the simple circuit that is true when both

40
00:02:24,970 --> 00:02:26,130
of its inputs are true

41
00:02:26,130 --> 00:02:29,160
is the AND gate so we can draw in

42
00:02:29,160 --> 00:02:33,290
an AND gate that's connected to the S pin
and its inputs

43
00:02:33,290 --> 00:02:36,490
are the clock signal and the D signal so when both of them

44
00:02:36,490 --> 00:02:40,459
are 1, then the output is true so the set pin
is taken high

45
00:02:40,459 --> 00:02:43,939
and the output of this sets the circuit.
Need to do the same to reset it

46
00:02:43,940 --> 00:02:46,180
& we want reset to be 1

47
00:02:46,190 --> 00:02:49,300
when D is zero and clock is one

48
00:02:49,300 --> 00:02:53,520
now an OR circuit's no good because if we
OR'd them then 1 & 1 would also be true

49
00:02:53,520 --> 00:02:56,970
and we wouldn't want reset and set to be
set at the same time

50
00:02:56,970 --> 00:03:00,050
so what we do is we use another AND gate, connect that up to the

51
00:03:00,050 --> 00:03:04,160
clock signal but we also need to have a
signal that is true

52
00:03:04,160 --> 00:03:07,480
when data or D is 0 and so the
easiest way to do that

53
00:03:07,480 --> 00:03:11,920
is to use a NOT gate like that and connect that into the circuit.

54
00:03:12,000 --> 00:03:15,000
Normally when we're writing circuits, drawing that out

55
00:03:15,000 --> 00:03:18,959
in full takes up a lot of space, so we
just reduce it down

56
00:03:18,959 --> 00:03:22,880
to a simple rectangle and this is what's
referred to

57
00:03:22,880 --> 00:03:27,260
as a 'D latch' and the reason why it's
called a latch is because

58
00:03:27,260 --> 00:03:31,430
when clock is high then the output will
follow whatever

59
00:03:31,430 --> 00:03:36,110
D is, it'll change as D changes
while the output is high. When clock is low

60
00:03:36,110 --> 00:03:40,650
the output is frozen at whatever it
previously was. There is another type of circuit

61
00:03:40,690 --> 00:03:43,970
which is called a flip flop, which is drawn in very similar

62
00:03:43,970 --> 00:03:48,579
fashion the difference with this though
is that the data is only remembered

63
00:03:48,579 --> 00:03:51,890
when this transitions from being low

64
00:03:51,890 --> 00:03:55,140
to high. So when the signal on this
input goes from being low

65
00:03:55,140 --> 00:03:58,260
to being high (this is at low and this is at high)

66
00:03:58,260 --> 00:04:01,310
as it's changing it remembers whatever
the data is

67
00:04:01,310 --> 00:04:04,560
at that point there and the rest of the time
it's fixed

68
00:04:04,560 --> 00:04:08,090
so it keeps that going - until it goes high again

69
00:04:08,090 --> 00:04:11,620
and it remembers at this point whatever it was when it changed from low

70
00:04:11,620 --> 00:04:15,780
to high. Both these circuits are used in
building computers but this one in

71
00:04:15,780 --> 00:04:17,260
particular can be used

72
00:04:17,260 --> 00:04:20,489
to build memory circuits that store
things

73
00:04:20,489 --> 00:04:24,760
so what we're going to do now is look at how we can put these together to build up

74
00:04:24,760 --> 00:04:28,480
memory for our computer. With the D flip-flop we can store a single bit

75
00:04:28,480 --> 00:04:32,040
of information but often on a computer
we want to store more than that.

76
00:04:32,040 --> 00:04:34,600
We want to store a byte, 32 bits worth and so on

77
00:04:34,600 --> 00:04:38,120
or we'll want have to have several bits and we can choose which one

78
00:04:38,130 --> 00:04:42,520
we want to select, so let's have a look at how we can store more than one bit

79
00:04:42,520 --> 00:04:47,060
Now the simplest case to understand when you install something like a byte

80
00:04:47,110 --> 00:04:53,230
or a 32-bit word or a 64-bit word or even a 128-bit word is something you get these days

81
00:04:53,230 --> 00:04:56,910
now the way you do that is - if you remember how binary

82
00:04:56,910 --> 00:05:00,190
numbers work, we store it as a series of bits.

83
00:05:00,190 --> 00:05:04,720
Inside a computer the data is stored along the various wires and each bit

84
00:05:04,720 --> 00:05:08,290
is stored on its own individual wires. If
you look carefully

85
00:05:08,290 --> 00:05:13,080
on the back of this motherboard you'll see
that coming off the processor here

86
00:05:13,080 --> 00:05:17,810
you have lots and lots of wires, that go
together. Now some of these are used to tell it

87
00:05:17,810 --> 00:05:20,680
where to store things but others
are actually carrying the data

88
00:05:20,680 --> 00:05:24,520
We've got 16 lines on the motherboard with
which to transfer the data between the

89
00:05:24,520 --> 00:05:28,800
various chips. Each wire stores one bit

90
00:05:28,810 --> 00:05:32,919
So one wire stores 'bit 0' - one wire stores 'bit 1' and so on.

91
00:05:32,919 --> 00:05:37,159
So our circuit uses several wires to
carry the data.

92
00:05:37,160 --> 00:05:42,460
Now if we wanted to store a 16- or
32-bit number it's very simple.

93
00:05:42,560 --> 00:05:45,940
We're gonna use four-bits here just because it saves on drawing

94
00:05:45,940 --> 00:05:52,180
So our input would be one, two, three, four input wires,

95
00:05:52,180 --> 00:05:54,620
and they'd be labelled something like that

96
00:05:54,630 --> 00:05:59,479
and if we wanted to store, say, that four bit
number, what we'd do is we'd have

97
00:05:59,479 --> 00:06:04,279
four flip-flops - and we connect each of the data pins,

98
00:06:04,340 --> 00:06:09,100
up to a different flip-flop, but we now need it to store things when we want it to,

99
00:06:09,100 --> 00:06:12,280
so remember we had this input here which when we took it from low to high

100
00:06:12,289 --> 00:06:16,020
would store everything well we just
connect them altogether

101
00:06:16,030 --> 00:06:19,330
like so, like that and then we have a
single signal

102
00:06:19,330 --> 00:06:22,970
here which we can use to tell it to store
anything - so when we put the data on here

103
00:06:22,970 --> 00:06:27,770
and transition this one from low to high
all four of these flip-flops will remember

104
00:06:27,770 --> 00:06:31,770
that data and the outputs here will be the data that we wanted to store.

105
00:06:31,770 --> 00:06:35,800
So storing multiple bits is really easy,
we just have multiple flip flops

106
00:06:35,800 --> 00:06:39,500
each flip-flop stores one particular bit of information

107
00:06:39,500 --> 00:06:42,960
If we wanted 8, then we'd have 8 flip-flops - if we wanted to store a 32-bit word

108
00:06:42,969 --> 00:06:44,289
we'd have 32

109
00:06:44,289 --> 00:06:48,169
now you can actually buy these pre-made
so what we've got here

110
00:06:48,169 --> 00:06:51,879
are 3 8-bit registers as they're called because they can store

111
00:06:51,879 --> 00:06:55,250
8 bits but they're basically just 8 flip
flops

112
00:06:55,250 --> 00:06:59,090
with 8 inputs and an input that we can
use to

113
00:06:59,090 --> 00:07:03,150
tell it to store things and the eight outputs and then you've got the voltage supply & the ground

114
00:07:03,160 --> 00:07:05,700
to actually power the chip.

115
00:07:07,680 --> 00:07:13,759
So that's how we can store multiple bits that are stored in parallel, that make up, say, a byte or so on.

116
00:07:13,759 --> 00:07:18,080
& if we look at this SIM that we took out of
the Apple Macintosh

117
00:07:18,080 --> 00:07:22,160
then we can see that there are 8 chips. Now you don't have to have them as separate chips

118
00:07:22,180 --> 00:07:23,620
but often they are so we've got 8 chips here

119
00:07:23,620 --> 00:07:28,280
and each one of these chips will be wired up to store a different bit of the byte.

120
00:07:28,440 --> 00:07:31,180
Doesn't have to be the case, if you look
at some other SIMs you'll find

121
00:07:31,180 --> 00:07:35,080
that they perhaps only have 2 chips in
or perhaps even just one and so on

122
00:07:35,420 --> 00:07:38,659
it doesn't make any difference 'cause the
implementation is the same

123
00:07:38,659 --> 00:07:43,359
but in this case they actually used 8 chips
on the SIM to store things.

124
00:07:43,620 --> 00:07:48,360
So that's how we can
store 8 bits whether a byte or a word we just have 8

125
00:07:48,430 --> 00:07:51,670
single bit 'things' in parallel.

126
00:07:51,860 --> 00:07:55,500
But, if you've done any programming with computers, you'll know that you can store

127
00:07:55,500 --> 00:07:59,099
more than one thing's and you can
address them all separately

128
00:07:59,099 --> 00:08:01,239
and we'll look at that in another video

129
00:08:03,960 --> 00:08:07,010
We'd like to thank Audible dot com for
sponsoring this Computerphile video

130
00:08:07,010 --> 00:08:10,840
if you like books you must check out
Audible. Go to Audible Dot Com

131
00:08:10,840 --> 00:08:13,910
slash Computerphile, there's a chance to
download one for free.

132
00:08:13,910 --> 00:08:17,680
Now today I'd like to recommend
Christopher Brookmyre as an author, he's

133
00:08:17,680 --> 00:08:19,180
an absolute genius in my mind

134
00:08:19,180 --> 00:08:22,500
try "A Snowball in Hell" which is a really
really good book

135
00:08:22,500 --> 00:08:26,230
if you like your novels dark it's very
clever it's quite funny with a dark

136
00:08:26,230 --> 00:08:27,060
sense of humor

137
00:08:27,060 --> 00:08:31,420
and it's well worth a read so check out
"A Snowball in Hell" by Christopher Brookmyre

138
00:08:31,420 --> 00:08:35,250
at Audible Dot Com slash Computerphile, and thanks once again

139
00:08:35,250 --> 00:08:37,950
to them for sponsoring this Computerphile
video.

140
00:08:38,160 --> 00:08:44,920
...and if we slide the front out, we can start to see how it is inside,

141
00:08:44,930 --> 00:08:48,380
so it's a CRT based monitor

142
00:08:48,380 --> 00:08:52,700
so you can see the tube at the back here -
and you'll notice I'm being very careful not...

