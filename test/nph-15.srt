1
00:00:00,269 --> 00:00:04,480
UTF-8 is perhaps the best hack,

2
00:00:04,480 --> 00:00:08,040
the best single thing that's used

3
00:00:08,040 --> 00:00:10,180
that can be written down on the back of a napkin,

4
00:00:10,180 --> 00:00:11,580
and that's how was it was put together.

5
00:00:11,590 --> 00:00:16,050
The first draft of UTF-8 was written on the back of a napkin in a diner

6
00:00:16,050 --> 00:00:18,410
and it's just such an elegant hack

7
00:00:18,410 --> 00:00:21,260
that solved so many problems and I
absolutely love it.

8
00:00:23,600 --> 00:00:24,720
Back in the 1960s,

9
00:00:24,730 --> 00:00:28,230
we had teleprinters, we had simple
devices where you type a key

10
00:00:28,230 --> 00:00:31,500
and it sends some numbers and the same letter comes out on the other side,

11
00:00:31,500 --> 00:00:34,649
but there needs to be a standard so in
the mid-1960s

12
00:00:34,649 --> 00:00:40,229
America, at least, settled on ASCII, which is the American Standard Code for Information Interchange,

13
00:00:40,230 --> 00:00:42,410
and it's a 7-bit binary system,

14
00:00:42,410 --> 00:00:43,940
so each letter you type in

15
00:00:43,940 --> 00:00:48,280
gets converted into 7 binary numbers and sent over the wire.

16
00:00:48,280 --> 00:00:52,760
Now that means you can have numbers from 0 to 127.

17
00:00:52,760 --> 00:00:58,340
They sort of moved the first 32 for control codes and less important stuff for writing,

18
00:00:58,340 --> 00:01:01,280
things like like "go down a line" or backspace.

19
00:01:01,860 --> 00:01:05,920
And then they made the rest characters. They added some numbers, some punctuation marks.

20
00:01:05,920 --> 00:01:12,460
They did a really clever thing, which is that they made 'A' 65 which, in binary—

21
00:01:12,460 --> 00:01:18,000
find 1, 2, 4, 8, 16, 32, 64—

22
00:01:18,000 --> 00:01:25,220
in binary, 65 is 1000001,

23
00:01:25,220 --> 00:01:31,340
which means that 'B' is 66, which means you've got 2 in binary just here.

24
00:01:31,340 --> 00:01:34,800
C, 67, 3 in binary.

25
00:01:34,800 --> 00:01:39,900
So you can look at a 7-bit binary character and just knock off the first two digits

26
00:01:39,900 --> 00:01:41,760
and know what its position in the alphabet is.

27
00:01:41,760 --> 00:01:45,800
Even cleverer than that, they started lowercase 32 later,

28
00:01:45,800 --> 00:01:51,980
which means that lowercase 'a' is 97—1100001.

29
00:01:51,980 --> 00:01:56,560
Anything that doesn't fit into that is probably a space, which conveniently will be all zeroes,

30
00:01:56,560 --> 00:01:58,600
or some kind of punctuation mark.

31
00:01:58,600 --> 00:02:01,900
Brilliant, clever, wonderful, great way of doing things,

32
00:02:01,900 --> 00:02:05,600
and that became the standard, at least in the English-speaking world.

33
00:02:05,600 --> 00:02:09,840
As for the rest of the world, a few of them did versions of that,

34
00:02:09,840 --> 00:02:14,780
but you start getting into other alphabets, into languages that don't really use alphabets at all.

35
00:02:14,780 --> 00:02:18,700
They all came up with their own encoding, which is fine.

36
00:02:18,700 --> 00:02:22,620
And then along come computers, and, over time, things change.

37
00:02:22,620 --> 00:02:28,660
We move to 8-bit computers, so we now have a whole extra number at the start just to confuse matters,

38
00:02:28,660 --> 00:02:32,800
which means we can go to 256! We can have twice as many characters!

39
00:02:32,800 --> 00:02:38,200
And, of course, everyone settled on the same standard for this, because that would make perfect s—

40
00:02:38,200 --> 00:02:39,060
No. None of them did.

41
00:02:39,060 --> 00:02:43,080
All the Nordic countries start putting Norwegian characters and Finnish characters in there.

42
00:02:43,080 --> 00:02:46,680
Japan just doesn't use ASCII at all.

43
00:02:46,680 --> 00:02:51,900
Japan goes and creates its own multibyte encoding with more letters and more characters

44
00:02:51,900 --> 00:02:54,440
and more binary numbers going to each individual character.

45
00:02:54,440 --> 00:02:57,640
All of these things are massively incompatible.

46
00:02:57,640 --> 00:03:04,680
Japan actually has three or four different encodings, all of which are completely incompatible with each other.

47
00:03:04,680 --> 00:03:08,700
So you send a document from one old-school Japanese computer to another,

48
00:03:08,700 --> 00:03:14,100
it will come out so garbled that there is even a word in Japanese for "garbled characters,"

49
00:03:14,100 --> 00:03:17,600
which is—I'm probably mispronouncing this—but it's "mojibake."

50
00:03:17,600 --> 00:03:19,380
It's a bit of a nightmare, but it's not bad,

51
00:03:19,380 --> 00:03:23,340
because how often does someone in London have to send a document

52
00:03:23,340 --> 00:03:27,660
to a completely incompatible and unknown computer at another company in Japan?

53
00:03:27,660 --> 00:03:30,960
In those days, it's rare. You printed it off and you faxed it.

54
00:03:30,960 --> 00:03:36,300
And then the World Wide Web hit, and we have a problem,

55
00:03:36,300 --> 00:03:41,140
because suddenly documents are being sent from all around the world all the time.

56
00:03:41,140 --> 00:03:44,280
So a thing is set up called the Unicode Consortium.

57
00:03:44,280 --> 00:03:53,240
In what I can only describe as a miracle, over the last couple of decades, they have hammered out a standard.

58
00:03:53,240 --> 00:03:58,660
Unicode now have a list of more than a hundred thousand characters

59
00:03:58,660 --> 00:04:02,460
that covers everything you could possibly want to write in any language—

60
00:04:02,460 --> 00:04:10,180
English alphabet, Cyrillic alphabet, Arabic alphabet, Japanese, Chinese, and Korean characters.

61
00:04:10,180 --> 00:04:17,800
What you have at the end is the Unicode Consortium assigning 100,000+ characters to 100,000 numbers.

62
00:04:17,800 --> 00:04:22,340
They have not chosen binary digits. They have not chosen what they should be represented as.

63
00:04:22,340 --> 00:04:28,700
All they have said is that THAT Arabic character there, that is number 5,700-something,

64
00:04:28,700 --> 00:04:32,840
and this linguistic symbol here, that's 10,000-something.

65
00:04:32,840 --> 00:04:35,460
I have to simplify massively here because there are about,

66
00:04:35,460 --> 00:04:38,820
of course, five or six incompatible ways to do this,

67
00:04:38,820 --> 00:04:43,360
but what the web has more or less settled on is something called "UTF-8."

68
00:04:43,360 --> 00:04:47,600
There are a couple of problems with doing the obvious thing, which is saying,

69
00:04:47,600 --> 00:04:50,080
"OK. We're going to 100,000.

70
00:04:50,080 --> 00:04:56,380
That's gonna need, what... to be safe, that's gonna need 32 binary digits to encode it."

71
00:04:56,380 --> 00:05:03,520
They encoded the English alphabet in exactly the same way as ASCII did. 'A' is still 65.

72
00:05:03,520 --> 00:05:09,740
So if you have just a string of English text, and you're encoding it at 32 bits per character,

73
00:05:09,740 --> 00:05:15,200
you're gonna have about 20-something... 26? Yeah.

74
00:05:15,200 --> 00:05:20,680
26, 27 zeroes and then a few ones for every single character.

75
00:05:20,680 --> 00:05:22,280
That is incredibly wasteful.

76
00:05:22,280 --> 00:05:27,300
Suddenly every English language text file takes four times the space on disk.

77
00:05:27,300 --> 00:05:30,560
So problem 1: you have to get rid of all the zeroes in the English text.

78
00:05:30,560 --> 00:05:37,260
Problem 2: there are lots of old computer systems that interpret 8 zeroes in a row,

79
00:05:37,260 --> 00:05:40,620
a NULL, as "this is the end of the string of characters."

80
00:05:40,620 --> 00:05:45,240
so if you ever send 8 zeroes in a row, they just stop listening.

81
00:05:45,240 --> 00:05:48,020
They assume the string has ended there, and it gets cut off,

82
00:05:48,020 --> 00:05:51,720
so you can't have 8 zeroes in a row anywhere.

83
00:05:51,720 --> 00:05:56,440
'K. Problem number 3: it has to be backwards-compatible.

84
00:05:56,440 --> 00:06:03,800
You have to be able to take this Unicode text and chuck it into something that only understands basic ASCII,

85
00:06:03,800 --> 00:06:06,660
and have it more or less work for English text.

86
00:06:06,660 --> 00:06:12,100
UTF-8 solves all of these problems and it's just a wonderful hack.

87
00:06:12,100 --> 00:06:14,960
It starts by just taking ASCII.

88
00:06:14,960 --> 00:06:20,800
If you have something under 128, that can just be expressed as 7 digits,

89
00:06:20,800 --> 00:06:25,460
you put down a zero, and then you put the same numbers that you would otherwise,

90
00:06:25,460 --> 00:06:29,820
so let's have that 'A' again—there we go!

91
00:06:29,820 --> 00:06:35,380
That's still 'A.' That's still 65. That's still UTF-8-valid, and that's still ASCII-valid. Brilliant.

92
00:06:35,380 --> 00:06:38,100
OK. Now let's say we're going above that.

93
00:06:38,100 --> 00:06:43,280
Now you need something that's gonna work more or less for ASCII, or at least not break things,

94
00:06:43,280 --> 00:06:44,580
but still be understood.

95
00:06:44,580 --> 00:06:49,180
So what you do is you start by writing down "110."

96
00:06:49,180 --> 00:06:54,560
This means this is the start of a new character, and this character is going to be 2 bytes long.

97
00:06:54,560 --> 00:06:57,360
Two ones, two bytes, a byte being 8 characters.

98
00:06:57,360 --> 00:07:01,380
And you say on this one, we're gonna start it with "10," which means this is a continuation,

99
00:07:01,380 --> 00:07:05,520
and at all these blank spaces, of which you have 5 here and 6 here,

100
00:07:05,520 --> 00:07:07,920
you fill in the other numbers,

101
00:07:07,920 --> 00:07:11,060
and then when you calculate it, you just take off those headers,

102
00:07:11,060 --> 00:07:15,280
and it understands just  as being whatever number that turns out to be.

103
00:07:15,280 --> 00:07:17,880
That's probably somewhere in the hundreds.

104
00:07:17,880 --> 00:07:22,220
That'll do you for the first 4,096. What about above that?

105
00:07:22,220 --> 00:07:28,640
Well, above that you go "1110," meaning there are three bytes in this—three ones, three bytes—

106
00:07:28,640 --> 00:07:30,500
with two continuation bytes.

107
00:07:30,500 --> 00:07:35,240
So now you have 1, 2, 3, 4, 10, 16 spaces.

108
00:07:35,240 --> 00:07:36,560
You want to go above that? You can.

109
00:07:36,560 --> 00:07:46,020
This specification goes all the way to "1111110x" with this many continuation bytes after it.

110
00:07:46,020 --> 00:07:50,000
It's a neat hack that you can explain on the back of a napkin or a bit of paper.

111
00:07:50,000 --> 00:07:57,420
It's backwards-compatible. It avoids waste. At no point will it ever, ever, ever send 8 zeroes in a row,

112
00:07:57,420 --> 00:08:01,960
and, really, really crucially, the one that made it win over every other system

113
00:08:01,960 --> 00:08:05,520
is that you can move backwards and forwards really easily.

114
00:08:05,520 --> 00:08:08,180
You do not have to have an index of where the character starts.

115
00:08:08,180 --> 00:08:12,520
If you are halfway through a string and you wanna go back one character,

116
00:08:12,520 --> 00:08:14,940
you just look for the previous header.

117
00:08:14,940 --> 00:08:16,060
And that's it, and that works,

118
00:08:16,060 --> 00:08:22,420
and, as of a few years ago, UTF-8 beat out ASCII and everything else as, for the first time,

119
00:08:22,420 --> 00:08:25,140
the dominant character encoding on the web.

120
00:08:25,140 --> 00:08:28,900
We don't have that mojibake that Japanese has.

121
00:08:28,900 --> 00:08:35,000
We have something that nearly works, and that is why it's the most beautiful hack that I can think of

122
00:08:35,000 --> 00:08:38,000
that is used around the world every second of every day.

123
00:08:40,840 --> 00:08:45,180
(BRADY HARAN)
-We'd like to think Audible.com for their support of this Computerphile video,

124
00:08:45,180 --> 00:08:49,880
and, if you register with Audible and go to audible.com/computerphile,

125
00:08:49,880 --> 00:08:52,640
you can download a free audiobook.

126
00:08:52,640 --> 00:08:58,200
They've got a huge range of books at Audible. I'd like to recommend "The Last Man On the Moon,"

127
00:08:58,200 --> 00:09:04,740
which is by Eugene Cernan who is the eleventh of twelve men to step onto the Moon.

128
00:09:04,740 --> 00:09:07,000
but he was the last man to step off the Moon,

129
00:09:07,000 --> 00:09:10,560
so I'm not sure whether or not he is "the last man on the Moon" or not.

130
00:09:10,560 --> 00:09:12,500
Sort of depends how you define it.

131
00:09:12,500 --> 00:09:17,660
But his book is really good, and what I really like about it is it's read by Cernan himself,

132
00:09:17,660 --> 00:09:18,760
which I think is pretty cool

133
00:09:18,760 --> 00:09:23,720
Again, thanks to Audible. Go to audible.com/computerphile

134
00:09:23,720 --> 00:09:25,100
and get a free audiobook.

135
00:09:25,100 --> 00:09:29,760
(TOM SCOTT)
-"... an old system that hasn't been programmed well will take those nice curly quotes

136
00:09:29,760 --> 00:09:33,560
that Microsoft Word has put into Unicode, and it will look at that and say,

137
00:09:33,560 --> 00:09:36,640
'That is three separate characters...' "

