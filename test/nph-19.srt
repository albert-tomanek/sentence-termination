1
00:00:00,000 --> 00:00:03,500
Today we are going to be talking about a problem in logic

2
00:00:03,500 --> 00:00:05,880
and how in solving that problem,

3
00:00:05,910 --> 00:00:10,250
Alan Turing almost inadvertently
invented the modern digital computer.

4
00:00:12,929 --> 00:00:16,890
So we start back at the beginning of the
20th century, where mathematicians had

5
00:00:16,890 --> 00:00:21,960
posed this problem - in logic we're
interested in finding "Do these premises

6
00:00:21,960 --> 00:00:27,660
entail this conclusion?" So premises are
the bits you start off with in an argument

7
00:00:27,660 --> 00:00:31,230
they are your -- the bits you know at the
beginning or your assumptions and the

8
00:00:31,230 --> 00:00:34,690
conclusion is the bit you want to
establish the bit that you reason to

9
00:00:34,710 --> 00:00:39,899
with your argument and we want to know
is there a test that will tell us

10
00:00:39,899 --> 00:00:43,140
yes for sure these premises do or don't

11
00:00:43,140 --> 00:00:47,219
entail this conclusion. Is there an
automatic way of finding out whether

12
00:00:47,219 --> 00:00:49,530
they do or whether they don't?

13
00:00:49,530 --> 00:00:53,430
So that's the problem, it's called the
decision problem.

14
00:00:53,430 --> 00:00:58,649
The mathematicians wanted to find out "Is
there an answer to the decision problem

15
00:00:58,649 --> 00:01:00,510
for first order logic?"

16
00:01:00,510 --> 00:01:04,500
that's the kind of logic you learn in
philosophy or mathematics at university

17
00:01:04,500 --> 00:01:09,810
so lots of mathematicians were trying to
work out is first order logic decidable

18
00:01:09,810 --> 00:01:13,680
that is can we automatically test
whether the premises entail the

19
00:01:13,680 --> 00:01:14,640
conclusion

20
00:01:14,640 --> 00:01:19,409
Alan Turing was one of the first to
discover that first order logic isn't

21
00:01:19,409 --> 00:01:23,640
decidable. To prove this

22
00:01:23,640 --> 00:01:28,320
it's really difficult conceptually
because you have to be able to show no

23
00:01:28,320 --> 00:01:35,159
possible program can give you the answer
but how do you do that how do you show

24
00:01:35,159 --> 00:01:38,250
something about every possible program

25
00:01:38,250 --> 00:01:41,340
you can't run through every program one
by one

26
00:01:41,340 --> 00:01:44,670
but Turing came up with a brilliant
solution

27
00:01:44,670 --> 00:01:47,909
his idea goes something like this

28
00:01:47,909 --> 00:01:52,829
suppose we have a program and let's just
draw it as a black box

29
00:01:53,610 --> 00:01:58,799
it's going to take some inputs and it's
going to give us some outputs

30
00:01:58,799 --> 00:02:04,799
our program is going to solve some
problem a problem like "Do the premises

31
00:02:04,800 --> 00:02:08,910
entail the conclusion" we ask it a
question and it will give us an answer

32
00:02:08,910 --> 00:02:12,030
yes or no

33
00:02:12,030 --> 00:02:17,190
now here's another question we can ask
let's look at all of those possible

34
00:02:17,190 --> 00:02:21,450
programs and we're just thinking of them
as black boxes at the moment we might

35
00:02:21,450 --> 00:02:26,819
want to know is this program given a
certain input going to give us an answer

36
00:02:26,819 --> 00:02:33,030
or is it going to trundle on forever and
never give us an answer that is is it

37
00:02:33,030 --> 00:02:35,400
going to halt or is it not going to halt

38
00:02:35,400 --> 00:02:39,569
eventually so think about your computer
running you want it to give you an

39
00:02:39,569 --> 00:02:42,989
answer of whether it's a good answer or
a bad answer

40
00:02:42,989 --> 00:02:47,760
it's better than no answer. No answer
would mean the computer trundles around

41
00:02:47,760 --> 00:02:51,510
forever and ever in a loop and you would
just never know whether it's going to

42
00:02:51,510 --> 00:02:54,000
finish today tomorrow or never

43
00:02:54,000 --> 00:03:00,390
so halting is good so there's another
question we can ask given some program

44
00:03:00,390 --> 00:03:01,800
and some input

45
00:03:01,800 --> 00:03:07,680
will it ever halt? Now it turns out that
our logical problem

46
00:03:08,280 --> 00:03:15,150
"Do these premises entail this conclusion?"
is very similar to this halting problem

47
00:03:15,720 --> 00:03:20,880
in fact if we can solve the logical
problem then we can solve the halting

48
00:03:20,880 --> 00:03:21,959
problem

49
00:03:21,959 --> 00:03:27,900
will this program halt on this input so
the clever part of Turing's proof is

50
00:03:27,900 --> 00:03:33,720
to show that it's impossible for any
machine however clever it is to solve

51
00:03:33,720 --> 00:03:38,880
the halting problem that is to tell us
whether a given machine with a given

52
00:03:38,880 --> 00:03:42,840
input will halt or not - and here's how
he did it

53
00:03:42,840 --> 00:03:47,970
let's suppose we've got a machine or a
program that solves the problem for us

54
00:03:48,480 --> 00:03:52,680
it solves the halting problem don't
worry about how it works let's just

55
00:03:52,680 --> 00:03:56,730
think of it as a black box taking the
description of a machine and an input

56
00:03:56,730 --> 00:03:58,829
and giving us an answer

57
00:03:58,829 --> 00:04:02,760
yes it will halt or no it won't halt
just suppose that's possible

58
00:04:03,480 --> 00:04:07,980
call that machine "h" for the halting
problem - if you give me that machine

59
00:04:07,980 --> 00:04:10,980
I can transform it into a different
machine like this

60
00:04:11,549 --> 00:04:16,049
I stick some extra bits on it so that if
it gives me a yes answer

61
00:04:16,709 --> 00:04:19,919
I make it loop forever without ever
stopping

62
00:04:20,549 --> 00:04:22,980
if it gives me a no answer on the other
hand

63
00:04:22,980 --> 00:04:27,390
and it's going to halt straight away
let's call that big machine

64
00:04:28,050 --> 00:04:35,130
the whole thing "h+" now here's another
question we can ask what happens if I

65
00:04:35,130 --> 00:04:43,350
feed the whole machine into itself so
i'm going to put h+ in here and h+

66
00:04:43,350 --> 00:04:44,520
in here

67
00:04:44,520 --> 00:04:51,870
so the question I'm now asking is I'm
feeding h+ into itself so i'm asking the

68
00:04:51,870 --> 00:04:58,410
question "Does h+ halt given input h+?"
and here's where it all goes wrong

69
00:04:58,410 --> 00:05:02,610
because if h plus does halt

70
00:05:02,610 --> 00:05:06,390
we get a yes answer but then it loops
forever

71
00:05:06,390 --> 00:05:10,980
so it doesn't halt on the other hand if
it doesn't halt

72
00:05:11,550 --> 00:05:16,620
we get a no answer but then it halts so
if it does halt then it doesn't halt

73
00:05:17,190 --> 00:05:22,350
but if it doesn't halt then it does
halt. Either way we get a contradiction

74
00:05:22,350 --> 00:05:27,420
it's a paradox but what that shows is we
started off assuming that we can solve

75
00:05:27,420 --> 00:05:28,530
the problem

76
00:05:28,530 --> 00:05:32,520
we've ended up with a paradox so our
assumption was bad

77
00:05:32,520 --> 00:05:36,120
it turns out there's no possible machine

78
00:05:36,120 --> 00:05:39,120
no possible program that solves the
halting problem

79
00:05:39,660 --> 00:05:44,070
the really clever bit about Turing's
idea is it doesn't matter what kind of

80
00:05:44,070 --> 00:05:49,200
program our machine is. It doesn't matter
whether it's an abstract algorithm

81
00:05:49,200 --> 00:05:52,770
whether it's a real computer, a physical
computer

82
00:05:52,770 --> 00:05:57,120
it doesn't matter what it is we've prove
that no such program as possible

83
00:06:00,249 --> 00:06:06,339
Turing as part of his argument had to
say a little bit about what's going on

84
00:06:06,340 --> 00:06:11,349
in these black boxes //DFB: and the idea is
that every card represents an instruction

85
00:06:11,349 --> 00:06:13,149
in the Turing machine

