1
00:00:00,000 --> 00:00:05,609
There are very good reasons for C
occupying a special place in the

2
00:00:05,609 --> 00:00:10,830
firmament of languages, although I think
one thing to say at the outset is [that] really

3
00:00:10,830 --> 00:00:19,020
it finds its maximum power - it's maximum
raison d'etre for even existing at all - if you

4
00:00:19,020 --> 00:00:27,180
think of it as being the classical
system implementation language. Again, for

5
00:00:27,180 --> 00:00:31,560
younger viewers, it's going to be hard to
understand and comprehend this. But if

6
00:00:31,560 --> 00:00:37,680
you go back to the early mainframe era
you're getting really, really, powerful

7
00:00:37,680 --> 00:00:42,840
computers - well by those days' standards -
coming along, from the early 60s

8
00:00:42,840 --> 00:00:49,620
onwards. They were so expensive they had
to be time-shared between lots of users

9
00:00:49,620 --> 00:00:55,100
and that in turn means you've got to
have system software that can multitask

10
00:00:55,100 --> 00:00:59,850
between different people, different
people's programs loaded in the

11
00:00:59,850 --> 00:01:04,049
machine at the same time, all being time-
sliced with a little bit of time. But at

12
00:01:04,049 --> 00:01:10,320
the same time, increasingly, computer
systems had to evolve into not just

13
00:01:10,320 --> 00:01:13,560
being able to print out your output and
your answers but to store it in a

14
00:01:13,560 --> 00:01:20,360
file; they had to run file systems. And
by the early 1970s you are in this

15
00:01:20,360 --> 00:01:26,790
incredible situation that one of the
biggest challenges in programming - a

16
00:01:26,790 --> 00:01:31,979
real-time challenge where you had to
keep people happy - was nothing more or

17
00:01:31,979 --> 00:01:37,170
less than the operating system in your
computer. One of the hardest challenges

18
00:01:37,170 --> 00:01:43,110
going. And, yeah, the wisdom was: "You will
only ever be able to do this in

19
00:01:43,110 --> 00:01:48,149
assembler". Some of the low-level tricks
you need to do in operating systems - you

20
00:01:48,149 --> 00:01:54,450
know the `real man' attitude: "Real Men use
assembler!" And I think a lot of people

21
00:01:54,450 --> 00:01:59,610
said: "No, there's some truth in that but
on the other hand just a little bit of

22
00:01:59,610 --> 00:02:05,610
higher-level operations - if only it could
be done without slowing the language

23
00:02:05,610 --> 00:02:09,569
down too much would help us stay sane. 
I think a lot of

24
00:02:09,569 --> 00:02:16,349
people, gradually, were, if you like,
embellishing assemblers to become macro-

25
00:02:16,349 --> 00:02:21,900
assemblers to try and give the kind of
higher-level approach to things that you

26
00:02:21,900 --> 00:02:26,250
got in high level languages. But on the
other side the opposing armies were always

27
00:02:26,250 --> 00:02:30,750
saying: "High-level languages -  they're so
inefficient! You need assembler for

28
00:02:30,750 --> 00:02:36,150
everything, ideally". Moore's Law put paid to
that, y'know. Yes, we can afford to use

29
00:02:36,150 --> 00:02:40,410
high-level languages for a lot more
things in the early 70s. Then there

30
00:02:40,410 --> 00:02:47,190
were a lot of experiments in trying, 
usually, to adapt existing languages for

31
00:02:47,190 --> 00:02:51,299
system implementation use. And
particularly ones that had started to

32
00:02:51,299 --> 00:02:56,280
build in some low-level operations for
bit twiddling. It was getting important

33
00:02:56,280 --> 00:03:01,590
to be able to dig down to the byte level and
get out characters. Looming up, just on

34
00:03:01,590 --> 00:03:07,590
the horizon, shock! horror! as if 16 bits
wasn't a toy computer - 8 bits [was] coming.

35
00:03:07,590 --> 00:03:13,230
So you needed a language to evolve that
could cope with different widths of

36
00:03:13,230 --> 00:03:20,160
objects. Of course as it becomes ... you go
through a sort of - like a minimum - in the

37
00:03:20,160 --> 00:03:24,540
curve. You know - we have to chop things
down in size because otherwise we can't

38
00:03:24,540 --> 00:03:28,639
make it at a price that people will buy.
But then, as hardware becomes cheaper,

39
00:03:28,639 --> 00:03:33,239
generally you then turn the corner. And
you could see it even in DEC and

40
00:03:33,239 --> 00:03:40,049
their PDP-11 minicomputers. Soon enough
they come along with a 32-bit computer

41
00:03:40,049 --> 00:03:44,720
[the VAX] which they can afford to make at long
last. And, of course, that was the era when

42
00:03:44,720 --> 00:03:51,150
discrete transistors and components, on
printed circuit boards, gave way to chip

43
00:03:51,150 --> 00:03:57,930
technology. So you have, like, LSI-11s.
It's large-scale integration, it's not

44
00:03:57,930 --> 00:04:01,470
separate components any more. And
gradually the curve turns the other way

45
00:04:01,470 --> 00:04:06,680
>> Sean: How did this change in architecture
feed back into the language choices then?

46
00:04:06,680 --> 00:04:16,010
>> DFB: Well, I think that it's two things. First
of all, can you get a system implementation

47
00:04:16,010 --> 00:04:22,070
language that helps you do low-level
things at a higher level? And I still

48
00:04:22,070 --> 00:04:28,160
think that, probably, you could say
that the most successful of all time - and on

49
00:04:28,160 --> 00:04:32,540
that front - was C. It's not that there weren't
others. There were things like Bliss, there

50
00:04:32,540 --> 00:04:39,470
were things like, even, Algol 68. And other
high-level languages, BCPL, were tried out.

51
00:04:39,470 --> 00:04:46,910
But C had the great advantage that you
could see how you might port it. Ah! yeah!

52
00:04:46,910 --> 00:04:50,660
Dennis, Ken all that. They're doing it on
the PDP-11; they'll be doing it on the

53
00:04:50,660 --> 00:04:56,150
VAX but up come the SUNs, all of a
sudden. The SUN servers. Hey! can we port

54
00:04:56,150 --> 00:05:00,020
UNIX to this? We're porting UNIX - we got to
get the C compiler working! Can you get

55
00:05:00,020 --> 00:05:04,730
the C compiler working - yes of
course you can. And it really stood the

56
00:05:04,730 --> 00:05:09,800
test of time. I mean when you look now, in
the `gcc' compiler, at the architectures

57
00:05:09,800 --> 00:05:15,380
that are supported, it just writes its
own brochure saying: "Just look at this, we

58
00:05:15,380 --> 00:05:20,090
can cope with anything!" However, the other
side of that, was then the

59
00:05:20,090 --> 00:05:24,590
differentiation to, if you like,
higher-level languages - even imperative

60
00:05:24,590 --> 00:05:31,400
ones - just became more marked. And I think
it was very interesting that - I think it

61
00:05:31,400 --> 00:05:37,010
was in the mid to late 80s - James Gosling
of Sun effectively ... it's people who

62
00:05:37,010 --> 00:05:40,730
run programmers and see how many
mistakes they make when they're using

63
00:05:40,730 --> 00:05:48,320
pointers. And, as far as I recall it, one
of the design requirements of Java was:

64
00:05:48,320 --> 00:05:52,430
"We're gonna ban pointers at user level".
When we start looking at why

65
00:05:52,430 --> 00:05:56,900
programs go wrong it's people who've
made mistakes with pointers. So therefore

66
00:05:56,900 --> 00:06:03,290
we're gonna ban them. I'm actually not
against that. If you really don't need to

67
00:06:03,290 --> 00:06:07,640
do low-level manipulations of pointers
then let the language do it for you.

68
00:06:07,640 --> 00:06:12,440
Or if it's like C++ where you could do
them and you say I don't want to do all

69
00:06:12,440 --> 00:06:17,090
my clever stuff under the hood - I'm not
writing an operating system. Yeah! get

70
00:06:17,090 --> 00:06:22,040
hold of a library full of functions and
trust them because they'll have been

71
00:06:22,040 --> 00:06:24,500
tested. They'll be efficient and all this kind

72
00:06:24,500 --> 00:06:29,510
of thing.  So, yes, things like functional

73
00:06:29,510 --> 00:06:35,680
languages, which of course always used to -
still do! -  get flak for being so slow,

74
00:06:35,680 --> 00:06:42,140
They became more and more possible to do
I suppose Brian [Kernighan] might say they got

75
00:06:42,140 --> 00:06:47,770
`less and less inefficient' y'know. But
no, it was a liberation to have that much

76
00:06:47,770 --> 00:06:52,160
compute power around that you didn't
have to think too much. I'm glad that

77
00:06:52,160 --> 00:06:56,420
many sensible souls on the comment
streams of recent videos have said this.

78
00:06:56,420 --> 00:07:00,620
It's no good getting theological about:
"You're not a real programmer if you don't

79
00:07:00,620 --> 00:07:05,200
program in C" or anything silly like
that. You've got to have an attitude of

80
00:07:05,200 --> 00:07:10,610
`horses for courses': the right programming
language for the right task. If it's

81
00:07:10,610 --> 00:07:15,200
yelling out to use Python, use Python. If
it's yelling out to use AWK - as I've

82
00:07:15,200 --> 00:07:21,080
been known to do ... Yeah! I tried out, as you
know, my Reed-Muller `messages from Mars'

83
00:07:21,080 --> 00:07:25,730
I got it ... hacked it together in AWK.
Well, why not? You can always take the

84
00:07:25,730 --> 00:07:29,630
view that if it's not efficient
enough we can drive down to a lower

85
00:07:29,630 --> 00:07:33,770
level, more efficient, language. But the
ability to try things out, without them

86
00:07:33,770 --> 00:07:38,060
taking hours and hours - because of really
fast hardware - is probably about the

87
00:07:38,060 --> 00:07:42,740
biggest liberation I can think of in
terms of my professional career as a

88
00:07:42,740 --> 00:07:46,280
computer scientist. 
>> Sean: You know I'm not a programmer. 
I mean, one day it might make a

89
00:07:46,280 --> 00:07:55,910
video - my bad exploration of BASIC in my
youth. But, as a non programmer I suppose

90
00:07:55,910 --> 00:08:01,820
I come at this and think, well, why can't
there be one thing that fits all and my

91
00:08:01,820 --> 00:08:06,680
kind of taking examples from
other parts of life. Presumably certain

92
00:08:06,680 --> 00:08:09,830
things are good for certain things like you say>
>> DFB:  I think that's right. I think that

93
00:08:09,830 --> 00:08:15,650
you see it in all sorts of other realms
in life. It's that you know the true

94
00:08:15,650 --> 00:08:20,690
professional tool for doing something - it
was probably very different from a user-level

95
00:08:20,690 --> 00:08:27,740
tool.  Y' know, I mean, if you go to a
hardware store and buy yourself a drill

96
00:08:27,740 --> 00:08:32,450
with a hammer action, you know that's a
very different object from what they

97
00:08:32,450 --> 00:08:37,220
would use industrially to hack into
buildings. It's in principle the same but

98
00:08:37,220 --> 00:08:42,139
the whole spec. and construction of it
is very different. And that's what we

99
00:08:42,139 --> 00:08:49,820
now have the ability to do, is to fit the 
language to the task.

100
00:08:49,820 --> 00:08:58,040
Of course, it still leaves a big problem
that lots and lots of software ideally

101
00:08:58,040 --> 00:09:02,509
should have been rewritten years ago.
Because the moment you get something

102
00:09:02,509 --> 00:09:07,509
that's good for its time, and works, the
temptation is just to leave it in place

103
00:09:07,509 --> 00:09:12,709
because it works and we daren't change it 
because so many things are dependent on it.

104
00:09:12,709 --> 00:09:18,529
So, this is why there are still 8-bit Z80
programs doing heaven knows what in the

105
00:09:18,529 --> 00:09:21,440
Armed Forces. There are probably still companies out

106
00:09:21,440 --> 00:09:27,459
there, in the wild, still using COBOL on
mainframes. You know [the] cost of a mainframe

107
00:09:27,459 --> 00:09:33,350
simulation these days? Peanuts! That
program [will] cost us a fortune to rewrite it.

108
00:09:33,350 --> 00:09:40,899
And it's bound to go wrong, And it's known
and reliable so that thing about having

109
00:09:40,899 --> 00:09:48,440
legacy software and hardware and it's so
difficult to trust to replacing it. It's

110
00:09:48,440 --> 00:09:52,839
still is going to be a problem eternally I think, that. 
>> Sean: well there is a

111
00:09:52,839 --> 00:09:59,810
well-known phrase: "If it ain't broken, don't fix it!" 
>> DFB: What's helped the `ain't broken'

112
00:09:59,810 --> 00:10:05,690
bit, you see, that's the thing, is that if
there's something rather exotic on the

113
00:10:05,690 --> 00:10:12,380
hardware front, from the 1960s, you no
longer have to literally build one of

114
00:10:12,380 --> 00:10:17,000
those. You can simulate its action. So as
long as you put a lot of effort into

115
00:10:17,000 --> 00:10:21,589
getting a good simulator going, then you
can carry on with the code you've had

116
00:10:21,589 --> 00:10:28,470
for 30-40 years in some cases.

